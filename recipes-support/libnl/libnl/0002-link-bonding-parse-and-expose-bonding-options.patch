From c55cf9afb4b959e697aae49d8e65bee69bb0a7af Mon Sep 17 00:00:00 2001
From: Jonas Gorski <jonas.gorski@bisdn.de>
Date: Tue, 6 Oct 2020 10:00:37 +0200
Subject: [PATCH 2/2] link/bonding: parse and expose bonding options

Signed-off-by: Jonas Gorski <jonas.gorski@bisdn.de>
---
 include/netlink/route/link/bonding.h |  12 ++
 lib/route/link/bonding.c             | 303 +++++++++++++++++++++++++++
 libnl-route-3.sym                    |   8 +
 3 files changed, 323 insertions(+)

diff --git a/include/netlink/route/link/bonding.h b/include/netlink/route/link/bonding.h
index 09d495e..56de595 100644
--- a/include/netlink/route/link/bonding.h
+++ b/include/netlink/route/link/bonding.h
@@ -25,6 +25,18 @@ extern int	rtnl_link_bond_enslave(struct nl_sock *, struct rtnl_link *,
 extern int	rtnl_link_bond_release_ifindex(struct nl_sock *, int);
 extern int	rtnl_link_bond_release(struct nl_sock *, struct rtnl_link *);
 
+extern int	rtnl_link_bond_set_mode(struct rtnl_link *, uint8_t);
+extern int	rtnl_link_bond_get_mode(struct rtnl_link *, uint8_t *);
+
+extern int	rtnl_link_bond_set_active_slave(struct rtnl_link *, uint32_t);
+extern int	rtnl_link_bond_get_active_slave(struct rtnl_link *, uint32_t *);
+
+extern int	rtnl_link_bond_set_primary(struct rtnl_link *, uint32_t);
+extern int	rtnl_link_bond_get_primary(struct rtnl_link *, uint32_t *);
+
+extern int	rtnl_link_bond_set_xmit_hash_policy(struct rtnl_link *, uint8_t);
+extern int	rtnl_link_bond_get_xmit_hash_policy(struct rtnl_link *, uint8_t *);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/lib/route/link/bonding.c b/lib/route/link/bonding.c
index 1d8f89b..aa43910 100644
--- a/lib/route/link/bonding.c
+++ b/lib/route/link/bonding.c
@@ -19,6 +19,134 @@
 #include <netlink/route/link/bonding.h>
 #include <netlink-private/route/link/api.h>
 
+/** @cond SKIP */
+#define BONDING_ATTR_MODE		(1 << 0)
+#define BONDING_ATTR_ACTIVE_SLAVE	(1 << 1)
+#define BONDING_ATTR_PRIMARY		(1 << 2)
+#define BONDING_ATTR_XMIT_HASH_POLICY	(1 << 3)
+
+struct bonding_info
+{
+	uint8_t  bi_mode;
+	uint32_t bi_active_slave;
+	uint32_t bi_primary;
+	uint8_t  bi_xmit_hash_policy;
+	uint32_t ce_mask;
+};
+
+/** @endcond */
+
+static struct nla_policy bonding_nl_policy[IFLA_BOND_MAX+1] = {
+	[IFLA_BOND_MODE]             = { .type = NLA_U8 },
+	[IFLA_BOND_ACTIVE_SLAVE]     = { .type = NLA_U32 },
+	[IFLA_BOND_PRIMARY]          = { .type = NLA_U32 },
+	[IFLA_BOND_XMIT_HASH_POLICY] = { .type = NLA_U8 },
+};
+
+static int bonding_alloc(struct rtnl_link *link)
+{
+	struct bonding_info *info;
+
+	if (link->l_info)
+		memset(link->l_info, 0, sizeof(*info));
+	else {
+		if ((info = calloc(1, sizeof(*info))) == NULL)
+			return -NLE_NOMEM;
+
+		link->l_info = info;
+	}
+	return 0;
+}
+
+static int bonding_parse(struct rtnl_link *link, struct nlattr *data,
+			struct nlattr *xstats)
+{
+	struct nlattr *tb[IFLA_BOND_MAX+1];
+	struct bonding_info *info;
+	int err;
+
+	NL_DBG(3, "Parsing bonding info\n");
+
+	if ((err = nla_parse_nested(tb, IFLA_BOND_MAX, data, bonding_nl_policy)) < 0)
+		goto errout;
+
+	if ((err = bonding_alloc(link)) < 0)
+		goto errout;
+
+	info = link->l_info;
+
+	if (tb[IFLA_BOND_MODE]) {
+		info->bi_mode = nla_get_u8(tb[IFLA_BOND_MODE]);
+		info->ce_mask |= BONDING_ATTR_MODE;
+	}
+
+	if (tb[IFLA_BOND_ACTIVE_SLAVE]) {
+		info->bi_active_slave = nla_get_u32(tb[IFLA_BOND_ACTIVE_SLAVE]);
+		info->ce_mask |= BONDING_ATTR_ACTIVE_SLAVE;
+	}
+
+	if (tb[IFLA_BOND_PRIMARY]) {
+		info->bi_primary = nla_get_u32(tb[IFLA_BOND_PRIMARY]);
+		info->ce_mask |= BONDING_ATTR_PRIMARY;
+	}
+
+	if (tb[IFLA_BOND_XMIT_HASH_POLICY]) {
+		info->bi_xmit_hash_policy = nla_get_u32(tb[IFLA_BOND_XMIT_HASH_POLICY]);
+		info->ce_mask |= BONDING_ATTR_XMIT_HASH_POLICY;
+	}
+
+	err = 0;
+errout:
+	return err;
+}
+
+static void bonding_free(struct rtnl_link *link)
+{
+	free(link->l_info);
+	link->l_info = NULL;
+}
+
+static int bonding_clone(struct rtnl_link *dst, struct rtnl_link *src)
+{
+	struct boding_info *vdst, *vsrc = src->l_info;
+	int err;
+
+	dst->l_info = NULL;
+	if ((err = rtnl_link_set_type(dst, "bond")) < 0)
+		return err;
+	vdst = dst->l_info;
+
+	if (!vdst || !vsrc)
+		return -NLE_NOMEM;
+
+	memcpy(vdst, vsrc, sizeof(struct bonding_info));
+
+	return 0;
+}
+
+static int bonding_put_attrs(struct nl_msg *msg, struct rtnl_link *link)
+{
+	struct bonding_info *info = link->l_info;
+	struct nlattr *data;
+
+	if (!(data = nla_nest_start(msg, IFLA_INFO_DATA)))
+		return -NLE_MSGSIZE;
+
+	if (info->ce_mask & BONDING_ATTR_MODE)
+		NLA_PUT_U8(msg, IFLA_BOND_MODE, info->bi_mode);
+	if (info->ce_mask & BONDING_ATTR_ACTIVE_SLAVE)
+		NLA_PUT_U32(msg, IFLA_BOND_ACTIVE_SLAVE, info->bi_active_slave);
+	if (info->ce_mask & BONDING_ATTR_PRIMARY)
+		NLA_PUT_U32(msg, IFLA_BOND_PRIMARY, info->bi_primary);
+	if (info->ce_mask & BONDING_ATTR_XMIT_HASH_POLICY)
+		NLA_PUT_U8(msg, IFLA_BOND_XMIT_HASH_POLICY, info->bi_xmit_hash_policy);
+
+	nla_nest_end(msg, data);
+
+nla_put_failure:
+	return 0;
+}
+
 /**
  * Allocate link object of type bond
  *
@@ -207,8 +335,183 @@ int rtnl_link_bond_release(struct nl_sock *sock, struct rtnl_link *slave)
 
 static struct rtnl_link_info_ops bonding_info_ops = {
 	.io_name		= "bond",
+	.io_alloc		= bonding_alloc,
+	.io_parse		= bonding_parse,
+	.io_clone		= bonding_clone,
+	.io_put_attrs		= bonding_put_attrs,
+	.io_free		= bonding_free,
 };
 
+/** @cond SKIP */
+#define IS_BONDING_LINK_ASSERT(link) \
+	if ((link)->l_info_ops != &bonding_info_ops) { \
+		APPBUG("Link is not a bonding link. set type \"bond\" first."); \
+		return -NLE_OPNOTSUPP; \
+	}
+/** @endcond */
+
+/**
+ * Set bonding mode
+ * @arg link		Link object
+ * @arg mode		bond mode
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_link_bond_set_mode(struct rtnl_link *link, uint8_t mode)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	info->bi_mode = mode;
+	info->ce_mask |= BONDING_ATTR_MODE;
+
+	return 0;
+}
+
+/**
+ * Get bonding mode
+ * @arg link		Link object
+ * @arg mode		bond mode
+ *
+ * @return bond mode, 0 if not set or a negative error code.
+ */
+int rtnl_link_bond_get_mode(struct rtnl_link *link, uint8_t *mode)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	if (!(info->ce_mask & BONDING_ATTR_MODE))
+		return -NLE_NOATTR;
+
+	if (mode)
+		*mode = info->bi_mode;
+
+	return 0;
+}
+
+/**
+ * Set bonding active slave
+ * @arg link		Link object
+ * @arg active_slave	active slave
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_link_bond_set_active_slave(struct rtnl_link *link, uint32_t active_slave)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	info->bi_active_slave = active_slave;
+	info->ce_mask |= BONDING_ATTR_ACTIVE_SLAVE;
+
+	return 0;
+}
+
+/**
+ * Get bonding mode
+ * @arg link		Link object
+ *
+ * @return bond mode, 0 if not set or a negative error code.
+ */
+int rtnl_link_bond_get_active_slave(struct rtnl_link *link, uint32_t *active_slave)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	if (!(info->ce_mask & BONDING_ATTR_ACTIVE_SLAVE))
+		return -NLE_NOATTR;
+
+	if (active_slave)
+		*active_slave = info->bi_active_slave;
+
+	return 0;
+}
+
+/**
+ * Set bonding primary
+ * @arg link		Link object
+ * @arg primary		primary
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_link_bond_set_primary(struct rtnl_link *link, uint32_t primary)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	info->bi_primary = primary;
+	info->ce_mask |= BONDING_ATTR_PRIMARY;
+
+	return 0;
+}
+
+/**
+ * Get bonding primary
+ * @arg link		Link object
+ *
+ * @return primary, 0 if not set or a negative error code.
+ */
+int rtnl_link_bond_get_primary(struct rtnl_link *link, uint32_t *primary)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	if (!(info->ce_mask & BONDING_ATTR_PRIMARY))
+		return -NLE_NOATTR;
+
+	if (primary)
+		*primary = info->bi_primary;
+
+	return 0;
+}
+
+/**
+ * Set bonding mode
+ * @arg link		Link object
+ * @arg mode		bond mode
+ *
+ * @return 0 on success or a negative error code.
+ */
+int rtnl_link_bond_set_xmit_hash_policy(struct rtnl_link *link, uint8_t policy)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	info->bi_xmit_hash_policy = policy;
+	info->ce_mask |= BONDING_ATTR_XMIT_HASH_POLICY;
+
+	return 0;
+}
+
+/**
+ * Get bonding mode
+ * @arg link		Link object
+ * @arg mode		bond mode
+ *
+ * @return bond mode, 0 if not set or a negative error code.
+ */
+int rtnl_link_bond_get_xmit_hash_policy(struct rtnl_link *link, uint8_t *policy)
+{
+	struct bonding_info *info = link->l_info;
+
+	IS_BONDING_LINK_ASSERT(link);
+
+	if (!(info->ce_mask & BONDING_ATTR_XMIT_HASH_POLICY))
+		return -NLE_NOATTR;
+
+	if (policy)
+		*policy = info->bi_xmit_hash_policy;
+
+	return 0;
+}
+
 static void __init bonding_init(void)
 {
 	rtnl_link_register_info(&bonding_info_ops);
diff --git a/libnl-route-3.sym b/libnl-route-3.sym
index af5c172..fcc9b1a 100644
--- a/libnl-route-3.sym
+++ b/libnl-route-3.sym
@@ -233,8 +233,16 @@ global:
 	rtnl_link_bond_alloc;
 	rtnl_link_bond_enslave;
 	rtnl_link_bond_enslave_ifindex;
+	rtnl_link_bond_get_active_slave;
+	rtnl_link_bond_get_mode;
+	rtnl_link_bond_get_primary;
+	rtnl_link_bond_get_xmit_hash_policy;
 	rtnl_link_bond_release;
 	rtnl_link_bond_release_ifindex;
+	rtnl_link_bond_set_active_slave;
+	rtnl_link_bond_set_mode;
+	rtnl_link_bond_set_primary;
+	rtnl_link_bond_set_xmit_hash_policy;
 	rtnl_link_bridge_add;
 	rtnl_link_bridge_alloc;
 	rtnl_link_bridge_flags2str;
-- 
2.28.0

