From 1d96ca54cedc34c7326e3d5f587c415dde05e727 Mon Sep 17 00:00:00 2001
From: Jonas Gorski <jonas.gorski@bisdn.de>
Date: Tue, 6 Oct 2020 15:25:38 +0200
Subject: [PATCH 1/2] WIP: add info slave data support

Signed-off-by: Jonas Gorski <jonas.gorski@bisdn.de>
---
 include/netlink-private/route/link/api.h | 33 ++++++++++
 include/netlink-private/types.h          |  2 +
 lib/route/link.c                         | 81 ++++++++++++++++++++----
 3 files changed, 105 insertions(+), 11 deletions(-)

diff --git a/include/netlink-private/route/link/api.h b/include/netlink-private/route/link/api.h
index 5ce24b1..b3aa5bc 100644
--- a/include/netlink-private/route/link/api.h
+++ b/include/netlink-private/route/link/api.h
@@ -58,6 +58,39 @@ struct rtnl_link_info_ops
 	int	      (*io_compare)(struct rtnl_link *, struct rtnl_link *,
 				    int flags);
 
+	/** Called to assign an info type to a link.
+	 * Has to allocate enough resources to hold attributes. Can
+	 * use link->l_info to store a pointer. */
+	int	      (*io_slave_alloc)(struct rtnl_link *);
+
+	/** Called to parse the link info attribute.
+	 * Must parse the attribute and assign all values to the link.
+	 */
+	int	      (*io_slave_parse)(struct rtnl_link *,
+				  struct nlattr *,
+				  struct nlattr *);
+
+	/** Called when the link object is dumped.
+	 * Must dump the info type specific attributes. */
+	void	      (*io_slave_dump[NL_DUMP_MAX+1])(struct rtnl_link *,
+						      struct nl_dump_params *);
+
+	/** Called when a link object is cloned.
+	 * Must clone all info type specific attributes. */
+	int	      (*io_slave_clone)(struct rtnl_link *, struct rtnl_link *);
+
+	/** Called when construction a slave link netlink message.
+	 * Must append all info type specific attributes to the message. */
+	int	      (*io_slave_put_attrs)(struct nl_msg *, struct rtnl_link *);
+
+	/** Called to release all resources previously allocated
+	 * in either io_slave_alloc() or io_slave_parse(). */
+	void	      (*io_slave_free)(struct rtnl_link *);
+
+	/** Called to compare slave link info parameters between two links. */
+	int	      (*io_slave_compare)(struct rtnl_link *, struct rtnl_link *,
+					  int flags);
+
 	struct nl_list_head		io_list;
 };
 
diff --git a/include/netlink-private/types.h b/include/netlink-private/types.h
index 94ae4e7..e751d8f 100644
--- a/include/netlink-private/types.h
+++ b/include/netlink-private/types.h
@@ -211,8 +211,10 @@ struct rtnl_link
 	char *				l_info_kind;
 	char *				l_info_slave_kind;
 	struct rtnl_link_info_ops *	l_info_ops;
+	struct rtnl_link_info_ops *	l_info_slave_ops;
 	void *				l_af_data[AF_MAX];
 	void *				l_info;
+	void *				l_info_slave;
 	char *				l_ifalias;
 	uint32_t			l_promiscuity;
 	uint32_t			l_num_tx_queues;
diff --git a/lib/route/link.c b/lib/route/link.c
index 1f0e028..520c91f 100644
--- a/lib/route/link.c
+++ b/lib/route/link.c
@@ -254,12 +254,29 @@ static void release_link_info(struct rtnl_link *link)
 	}
 }
 
+static void release_link_info_slave(struct rtnl_link *link)
+{
+	struct rtnl_link_info_ops *io = link->l_info_slave_ops;
+
+	if (io != NULL) {
+		if (io->io_slave_free)
+			io->io_slave_free(link);
+		else {
+			/* Catch missing io_free() implementations */
+			BUG_ON(link->l_info_slave);
+		}
+		rtnl_link_info_ops_put(io);
+		link->l_info_slave_ops = NULL;
+	}
+}
+
 static void link_free_data(struct nl_object *c)
 {
 	struct rtnl_link *link = nl_object_priv(c);
 
 	if (link) {
 		release_link_info(link);
+		release_link_info_slave(link);
 
 		/* proto info af reference */
 		rtnl_link_af_ops_put(link->l_af_ops);
@@ -313,6 +330,12 @@ static int link_clone(struct nl_object *_dst, struct nl_object *_src)
 			return err;
 	}
 
+	if (src->l_info_slave_ops && src->l_info_ops->io_slave_clone) {
+		err = src->l_info_slave_ops->io_slave_clone(dst, src);
+		if (err < 0)
+			return err;
+	}
+
 	if ((err = do_foreach_af(src, af_clone, dst)) < 0)
 		return err;
 
@@ -371,6 +394,8 @@ static struct nla_policy link_info_policy[IFLA_INFO_MAX+1] = {
 	[IFLA_INFO_KIND]	= { .type = NLA_STRING },
 	[IFLA_INFO_DATA]	= { .type = NLA_NESTED },
 	[IFLA_INFO_XSTATS]	= { .type = NLA_NESTED },
+	[IFLA_INFO_SLAVE_KIND]	= { .type = NLA_STRING },
+	[IFLA_INFO_SLAVE_DATA]	= { .type = NLA_NESTED },
 };
 
 int rtnl_link_info_parse(struct rtnl_link *link, struct nlattr **tb)
@@ -679,12 +704,27 @@ static int link_msg_parser(struct nl_cache_ops *ops, struct sockaddr_nl *who,
 		}
 
 		if (li[IFLA_INFO_SLAVE_KIND]) {
+			struct rtnl_link_info_ops *ops;
 			const char *kind = nla_get_string(li[IFLA_INFO_SLAVE_KIND]);
 
 			err = rtnl_link_set_slave_type(link, kind);
 			if (err < 0)
 				goto errout;
 
+			ops = link->l_info_slave_ops;
+
+			if (ops) {
+				if (ops->io_slave_parse &&
+				    (li[IFLA_INFO_SLAVE_DATA] || li[IFLA_INFO_XSTATS])) {
+					err = ops->io_slave_parse(link, li[IFLA_INFO_SLAVE_DATA],
+								  li[IFLA_INFO_XSTATS]);
+					if (err < 0)
+						goto errout;
+				} else {
+					/* XXX: Warn about unparsed info? */
+				}
+			}
+
 			link->ce_mask |= LINK_ATTR_LINKINFO_SLAVE_KIND;
 		}
 	}
@@ -1588,6 +1629,12 @@ static int build_link_msg(int cmd, struct ifinfomsg *hdr,
 
 		if (link->ce_mask & LINK_ATTR_LINKINFO_SLAVE_KIND) {
 			NLA_PUT_STRING(msg, IFLA_INFO_SLAVE_KIND, link->l_info_slave_kind);
+
+			if (link->l_info_slave_ops) {
+				if (link->l_info_slave_ops->io_put_attrs &&
+				    link->l_info_slave_ops->io_put_attrs(msg, link) < 0)
+					goto nla_put_failure;
+			}
 		}
 
 		nla_nest_end(msg, info);
@@ -2586,21 +2633,37 @@ char *rtnl_link_get_type(struct rtnl_link *link)
 int rtnl_link_set_slave_type(struct rtnl_link *link, const char *type)
 {
 	char *kind;
+	struct rtnl_link_info_ops *io;
+	int err;
 
 	free(link->l_info_slave_kind);
 	link->ce_mask &= ~LINK_ATTR_LINKINFO_SLAVE_KIND;
+	release_link_info_slave(link);
 
 	if (!type)
 		return 0;
 
 	kind = strdup(type);
 	if (!kind)
 		return -NLE_NOMEM;
 
+	io = rtnl_link_info_ops_lookup(type);
+	if (io) {
+		if (   io->io_slave_alloc
+		    && (err = io->io_slave_alloc(link)) < 0)
+			goto errout;
+
+		link->l_info_slave_ops = io;
+ 	}
+ 
 	link->l_info_slave_kind = kind;
 	link->ce_mask |= LINK_ATTR_LINKINFO_SLAVE_KIND;
 
 	return 0;
+
+errout:
+	free(kind);
+	return err;
 }
 
 /**
-- 
2.28.0

