From 65246ee4fd7c9b633d01bc7bf6ed3490b9ba1a9c Mon Sep 17 00:00:00 2001
From: Jonas Gorski <jonas.gorski@bisdn.de>
Date: Tue, 26 Jan 2021 10:21:08 +0100
Subject: [PATCH 4/4] WIP: pvstate

---
 bridge_ctl.h   |  12 ++++
 bridge_track.c | 132 ++++++++++++++++++++++++++++++++++++++++--
 bridge_track.h |   1 +
 brmon.c        | 151 ++++++++++++++++++++++++++++++++++++++++++++++++-
 mstp.h         |   1 +
 5 files changed, 289 insertions(+), 8 deletions(-)

diff --git a/bridge_ctl.h b/bridge_ctl.h
index d09a8b4..2590b20 100644
--- a/bridge_ctl.h
+++ b/bridge_ctl.h
@@ -31,6 +31,9 @@
 #include <net/if.h>
 #include <linux/if_ether.h>
 
+/* VLAN not present */
+#define VLAN_STATE_UNASSIGNED	0xff
+
 typedef struct
 {
     int if_index;
@@ -48,6 +51,9 @@ typedef struct
 
     bool up;
     int speed, duplex;
+
+    /* current per vlan state */
+    __u8 vlan_state[4095];
 } sysdep_if_data_t;
 
 #define GET_PORT_SPEED(port)    ((port)->sysdeps.speed)
@@ -79,6 +85,8 @@ typedef struct
 
 extern struct rtnl_handle rth_state;
 
+extern bool have_per_vlan_state;
+
 int init_bridge_ops(void);
 
 int bridge_notify(int br_index, int if_index, bool newlink, unsigned flags);
@@ -87,4 +95,8 @@ void bridge_bpdu_rcv(int ifindex, const unsigned char *data, int len);
 
 void bridge_one_second(void);
 
+int vlan_notify(int if_index, bool newvlan, __u16 vid, __u8 state);
+
+int fill_vlan_table(int if_index, __u8 *vlan_table);
+
 #endif /* BRIDGE_CTL_H */
diff --git a/bridge_track.c b/bridge_track.c
index 968e15b..05de242 100644
--- a/bridge_track.c
+++ b/bridge_track.c
@@ -46,6 +46,7 @@
 #endif
 
 static LIST_HEAD(bridges);
+static LIST_HEAD(ports);
 
 static bridge_t * create_br(int if_index)
 {
@@ -105,11 +106,15 @@ static port_t * create_if(bridge_t * br, int if_index)
         goto err;
     }
 
+    memset(prt->sysdeps.vlan_state, VLAN_STATE_UNASSIGNED, sizeof(prt->sysdeps.vlan_state));
+    fill_vlan_table(if_index, prt->sysdeps.vlan_state);
+
     INFO("Add iface %s as port#%d to bridge %s", prt->sysdeps.name,
          portno, br->sysdeps.name);
     prt->bridge = br;
     if(!MSTP_IN_port_create_and_add_tail(prt, portno))
         goto err;
+    list_add_tail(&prt->list, &ports);
 
     return prt;
 err:
@@ -120,16 +125,28 @@ err:
 static port_t * find_if(bridge_t * br, int if_index)
 {
     port_t *prt;
-    list_for_each_entry(prt, &br->ports, br_list)
+    if (br)
+    {
+        list_for_each_entry(prt, &br->ports, br_list)
+        {
+            if(prt->sysdeps.if_index == if_index)
+                return prt;
+        }
+    }
+    else
     {
-        if(prt->sysdeps.if_index == if_index)
-            return prt;
+        list_for_each_entry(prt, &ports, list)
+        {
+            if(prt->sysdeps.if_index == if_index)
+                return prt;
+        }
     }
     return NULL;
 }
 
 static inline void delete_if(port_t *prt)
 {
+    list_del(&prt->list);
     MSTP_IN_delete_port(prt);
     free(prt);
 }
@@ -347,6 +364,49 @@ int bridge_notify(int br_index, int if_index, bool newlink, unsigned flags)
     return 0;
 }
 
+static int br_set_vlan_state(struct rtnl_handle *rth, unsigned ifindex, __u16 vid, __u8 state);
+
+int vlan_notify(int if_index, bool newvlan, __u16 vid, __u8 state)
+{
+    per_tree_port_t *ptp;
+    bridge_t *br = NULL;
+    port_t *prt = NULL;
+    __u16 fid, mstid;
+
+    LOG("if_index %d, newvlan %d, vid %d, state %d",
+        if_index, newvlan, vid, state);
+
+    prt = find_if(NULL, if_index);
+    if (!prt)
+        return 0;
+
+    br = prt->bridge;
+    prt->sysdeps.vlan_state[vid] = state;
+
+    fid = br->vid2fid[vid];
+    mstid = br->fid2mstid[fid];
+
+    list_for_each_entry(ptp, &prt->trees, port_list)
+    {
+        if (ptp->MSTID != mstid)
+            continue;
+
+        if (ptp->state == state)
+	{
+            LOG_MSTINAME(br, prt, ptp, "VID %i: already in desired STP state %i", vid, ptp->state);
+            continue;
+	}
+
+        if (0 > br_set_vlan_state(&rth_state, if_index, vid, ptp->state))
+        {
+            ERROR_MSTINAME(br, prt, ptp, "VID %i: failed setting STP state %i in kernel", vid, ptp->state);
+        }
+
+    }
+
+    return 0;
+}
+
 struct llc_header
 {
     __u8 dest_addr[ETH_ALEN];
@@ -410,6 +470,46 @@ void bridge_bpdu_rcv(int if_index, const unsigned char *data, int len)
                     (bpdu_t *)(data + sizeof(*h)), l - LLC_PDU_LEN_U);
 }
 
+static int br_set_vlan_state(struct rtnl_handle *rth, unsigned ifindex, __u16 vid, __u8 state)
+{
+    struct
+    {
+        struct nlmsghdr n;
+        struct br_vlan_msg bvm;
+        char buf[256];
+    } req;
+    char entry_buf[256];
+    struct rtattr *rta = (void *)entry_buf;
+    struct bridge_vlan_info vlan_info;
+    struct rtattr *nest;
+
+    LOG("ifindex %d vid %d state %d", ifindex, vid, state);
+
+    memset(&req, 0, sizeof(req));
+
+    req.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct br_vlan_msg));
+    req.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE;
+    req.n.nlmsg_type = RTM_NEWVLAN;
+    req.bvm.family = AF_BRIDGE;
+    req.bvm.ifindex = ifindex;
+
+    rta->rta_type = BRIDGE_VLANDB_ENTRY;
+    rta->rta_len = RTA_LENGTH(0);
+
+    vlan_info.vid = vid;
+    vlan_info.flags = BRIDGE_VLAN_INFO_ONLY_OPTS;
+
+    nest = rta_nest(rta, sizeof(entry_buf), BRIDGE_VLANDB_ENTRY);
+    rta_addattr_l(rta, sizeof(entry_buf), BRIDGE_VLANDB_ENTRY_INFO, &vlan_info, sizeof(vlan_info));
+    rta_addattr8(rta, sizeof(entry_buf), BRIDGE_VLANDB_ENTRY_STATE, state);
+
+    rta_nest_end(rta, nest);
+
+    addraw_l(&req.n, sizeof(req.buf), RTA_DATA(rta), RTA_PAYLOAD(rta));
+
+    return rtnl_talk(rth, &req.n, 0, 0, NULL, NULL, NULL);
+}
+
 static int br_set_state(struct rtnl_handle *rth, unsigned ifindex, __u8 state)
 {
     struct
@@ -493,9 +593,29 @@ void MSTP_OUT_set_state(per_tree_port_t *ptp, int new_state)
     }
     INFO_MSTINAME(br, prt, ptp, "entering %s state", state_name);
 
-    /* Translate new CIST state to the kernel bridge code */
-    if(0 == ptp->MSTID)
-    { /* CIST */
+    if(have_per_vlan_state)
+    {
+        int i;
+
+        for (i = 1; i <= MAX_VID; i++)
+        {
+            __u16 fid = br->vid2fid[i];
+
+            if (br->fid2mstid[fid] != ptp->MSTID)
+                continue;
+
+            if (prt->sysdeps.vlan_state[i] == VLAN_STATE_UNASSIGNED)
+                continue;
+
+            if(0 > br_set_vlan_state(&rth_state, prt->sysdeps.if_index, i, ptp->state))
+               ERROR_PRTNAME(br, prt, "Couldn't set kernel bridge state %s for vid %i",
+                             state_name, i);
+            prt->sysdeps.vlan_state[i] = new_state;
+        }
+    }
+    else if(0 == ptp->MSTID)
+    {
+        /* Translate new CIST state to the kernel bridge code */
         if(0 > br_set_state(&rth_state, prt->sysdeps.if_index, ptp->state))
             ERROR_PRTNAME(br, prt, "Couldn't set kernel bridge state %s",
                           state_name);
diff --git a/bridge_track.h b/bridge_track.h
index d3aec99..a1083fa 100644
--- a/bridge_track.h
+++ b/bridge_track.h
@@ -21,6 +21,7 @@
 #ifndef MSTPD_BRIDGE_TRACK_H
 #define MSTPD_BRIDGE_TRACK_H
 
+
 int bridge_track_fini(void);
 
 #endif
diff --git a/brmon.c b/brmon.c
index aa7e3b7..5a9433c 100644
--- a/brmon.c
+++ b/brmon.c
@@ -17,6 +17,7 @@
 #include <stdlib.h>
 #include <fcntl.h>
 #include <netinet/in.h>
+#include <string.h>
 #include <linux/if_bridge.h>
 
 #include "log.h"
@@ -58,8 +59,10 @@ static struct epoll_event_handler br_handler;
 
 struct rtnl_handle rth_state;
 
-static int dump_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
-                    void *arg)
+bool have_per_vlan_state = 1;
+
+static int dump_br_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                       void *arg)
 {
     struct ifinfomsg *ifi = NLMSG_DATA(n);
     struct rtattr * tb[IFLA_MAX + 1];
@@ -166,6 +169,144 @@ static int dump_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
     return 0;
 }
 
+static int dump_vlan_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                         void *arg)
+{
+    struct br_vlan_msg *bvm = NLMSG_DATA(n);
+    struct rtattr *pos;
+    int len = n->nlmsg_len;
+    bool newvlan = n->nlmsg_type == RTM_NEWVLAN;
+
+    for (pos = NLMSG_DATA(n) + NLMSG_ALIGN(sizeof(*bvm)); RTA_OK(pos, len); pos = RTA_NEXT(pos, len))
+    {
+        struct rtattr *tb[BRIDGE_VLANDB_ENTRY_MAX +1];
+        struct bridge_vlan_info *info = NULL;
+        uint8_t state = VLAN_STATE_UNASSIGNED;
+        uint16_t range = 0;
+        uint16_t i;
+
+        if ((pos->rta_type & NLA_TYPE_MASK) != BRIDGE_VLANDB_ENTRY)
+            continue;
+
+        parse_rtattr_nested(tb, BRIDGE_VLANDB_ENTRY_MAX, pos);
+
+        if (tb[BRIDGE_VLANDB_ENTRY_INFO])
+            info = RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_INFO]);
+        if (tb[BRIDGE_VLANDB_ENTRY_STATE])
+            state = *(uint8_t *)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_STATE]);
+        if (tb[BRIDGE_VLANDB_ENTRY_RANGE])
+            range = *(uint16_t*)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_RANGE]);
+
+        if (!info)
+            continue;
+
+        if (!range)
+            range = info->vid;
+
+        for (i = info->vid;  i <= range; i++)
+            vlan_notify(bvm->ifindex, newvlan, i, state);
+    }
+
+    return 0;
+}
+
+struct vlan_dump_table {
+    int if_index;
+    uint8_t *table;
+};
+
+static int vlan_table_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                          void *arg)
+{
+    struct br_vlan_msg *bvm = NLMSG_DATA(n);
+    struct rtattr *pos;
+    int len = n->nlmsg_len;
+    struct vlan_dump_table *req = arg;
+
+    if (bvm->ifindex != req->if_index)
+            return 0;
+
+    for (pos = NLMSG_DATA(n) + NLMSG_ALIGN(sizeof(*bvm)); RTA_OK(pos, len); pos = RTA_NEXT(pos, len))
+    {
+        struct rtattr *tb[BRIDGE_VLANDB_ENTRY_MAX +1];
+        struct bridge_vlan_info *info = NULL;
+        uint8_t state = VLAN_STATE_UNASSIGNED;
+        uint16_t range = 0;
+        uint16_t i;
+
+        if ((pos->rta_type & NLA_TYPE_MASK) != BRIDGE_VLANDB_ENTRY)
+            continue;
+
+        parse_rtattr_nested(tb, BRIDGE_VLANDB_ENTRY_MAX, pos);
+
+        if (tb[BRIDGE_VLANDB_ENTRY_INFO])
+            info = RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_INFO]);
+        if (tb[BRIDGE_VLANDB_ENTRY_STATE])
+            state = *(uint8_t *)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_STATE]);
+        if (tb[BRIDGE_VLANDB_ENTRY_RANGE])
+            range = *(uint16_t*)RTA_DATA(tb[BRIDGE_VLANDB_ENTRY_RANGE]);
+
+        if (!info)
+            continue;
+
+        if (!range)
+            range = info->vid;
+
+        for (i = info->vid; i <= range; i++)
+            req->table[i] = state;
+    }
+
+    return 0;
+}
+
+static int dump_msg(const struct sockaddr_nl *who, struct nlmsghdr *n,
+                    void *arg)
+{
+    switch (n->nlmsg_type)
+    {
+        case RTM_NEWLINK:
+        case RTM_DELLINK:
+            return dump_br_msg(who, n, arg);
+        case RTM_NEWVLAN:
+        case RTM_DELVLAN:
+            return dump_vlan_msg(who, n, arg);
+        default:
+            return 0;
+    }
+}
+
+int fill_vlan_table(int if_index, uint8_t *vlan_table)
+{
+    struct br_vlan_msg bvm = {
+        .family = PF_BRIDGE,
+     /* .ifindex = if_index, */
+    };
+    struct vlan_dump_table req = {
+        .if_index = if_index,
+        .table = vlan_table,
+    };
+
+    if(!have_per_vlan_state)
+        return 0;
+
+    /* For unknown reason setting ifindex to non-zero will cause the kernel
+     * to flood us with the same message over and over again, so filter
+     * within mstpd for now */
+    if(rtnl_dump_request(&rth, RTM_GETVLAN, &bvm, sizeof(bvm)) < 0)
+    {
+        ERROR("Cannot send dump request: %m\n");
+        return -1;
+    }
+
+    if(rtnl_dump_filter(&rth, vlan_table_msg, &req, NULL, NULL) < 0)
+    {
+        ERROR("Dump terminated\n");
+        return -1;
+    }
+
+    return 0;
+}
+
 static inline void br_ev_handler(uint32_t events, struct epoll_event_handler *h)
 {
     if(rtnl_listen(&rth, dump_msg, stdout) < 0)
@@ -182,6 +323,12 @@ int init_bridge_ops(void)
         return -1;
     }
 
+    if(rtnl_add_nl_group(&rth, RTNLGRP_BRVLAN) < 0)
+    {
+        ERROR("Couldn't join RTNLGRP_BRVLAN, per vlan STP state not available\n");
+        have_per_vlan_state = 0;
+    }
+
     if(rtnl_open(&rth_state, 0) < 0)
     {
         ERROR("Couldn't open rtnl socket for setting state\n");
diff --git a/mstp.h b/mstp.h
index 983fd55..7bbdfff 100644
--- a/mstp.h
+++ b/mstp.h
@@ -443,6 +443,7 @@ typedef struct
 typedef struct
 {
     struct list_head br_list; /* anchor in bridge's list of ports */
+    struct list_head list; /* list of all interfaces */
     bridge_t * bridge;
     __be16 port_number;
 
-- 
2.30.0

